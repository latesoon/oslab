# lab2 操作系统实验报告

### 姚知言 2211290 贾景顺 2211312 李政远 2211320

### Challenge2：任意大小的内存单元slub分配算法

>slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。
参考linux的slub分配算法，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。


#### SLUB思路和原理
SLUB 是 Linux 内核中用于管理内核对象的高效内存分配算法之一，用于提高分配效率并减少碎片。代码方面由于某些原因难以实现，在以下讲解slub整体思路和原理。
SLUB 的核心思想采用了双层架构，第一层利用页（page）来管理内存，当需要分配对象时，系统会从对象分配池中提供内存块。这些 slab 是由若干个页组成的。
核心是第二层管理，通过slab把页在细分得到更小内存块。
第一层管理内存的方式一般为buddy system。

SLUB的前身是SLAB，他们整体的思路是提前储存空闲的页面并加入至空闲队列中（SLAB），在需要空闲页块的时候可以直接给出队伍中的页块，快速分配。
而SLUB不同的是，SLAB是以链表的方式储存，所以链表中指向下一个元素指针本身会占用内存，SLUB是将指向下一个元素指针储存在自身结构体内，这些对象结构体叫做kmem_cache。他们通过双向链表连接，并可以通过导出的slab_caches变量从内核中的任何位置访问。
kmem_cache中存储了两种指针以跟踪对象，kmem_cache_node跟踪不活动的partial和full的对象，在空闲的情况被访问，或者当活动的slab被填满时用另一个partial替换它；kmem_cache_cpu管理活动的slab，它只有一个，并且与当前的CPU相关（不同的处理器有不同的缓存）。下一次申请始终由freelist字段指向的slab返回。

#### SLUB普通分配
分配器从kmem_cache找到kmem_cache_cpu访问freelist找到第一个空闲对象，返回该对象（蓝色部分）。相应的更新指针将其从链表中删除，并将freelist指向下一个空闲对象
在分配即将满的对象时，返回最后一个对象后，已填满的页面将移动到full list中，将另一个partial list置为活动的slab